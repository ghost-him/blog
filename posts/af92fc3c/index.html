<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <link rel="manifest" href="/manifest.json">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css" integrity="sha256-dABdfBfUoC8vJUBOwGVdm8L9qlMWaHTIfXt+7GnZCIo=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/themes/blue/pace-theme-minimal.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous" defer></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Pisces","darkmode":false,"version":"8.23.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":true,"style":"mac"},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":true,"pangu":true,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js" defer></script>



<link rel="canonical" href="http://example.com/posts/af92fc3c/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://example.com/posts/af92fc3c/","path":"posts/af92fc3c/","title":"深度学习：算法到实战学习笔记01"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>深度学习：算法到实战学习笔记01 | ghost-him|🏠个人博客</title>
  








  
  <script size="300" alpha="0.6" zIndex="-1" src="https://cdnjs.cloudflare.com/ajax/libs/ribbon.js/1.0.2/ribbon.min.js" defer></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/next-theme-pjax/0.6.0/pjax.min.js" integrity="sha256-vxLn1tSKWD4dqbMRyv940UYw4sXgMtYcK6reefzZrao=" crossorigin="anonymous" defer></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/lozad.js/1.16.0/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous" defer></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pangu/4.0.7/pangu.min.js" integrity="sha256-j+yj56cdEY2CwkVtGyz18fNybFGpMGJ8JxG3GSyO2+I=" crossorigin="anonymous" defer></script>
<script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script><script src="/js/pjax.js" defer></script>

  

  <script class="next-config" data-name="mermaid" type="application/json">{"enable":true,"theme":{"light":"default","dark":"dark"},"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mermaid/11.5.0/mermaid.min.js","integrity":"sha256-2obLuIPcceEhkE3G09G33hBdmE55ivVcZUlcKcGNHjU="}}</script>
  <script src="/js/third-party/tags/mermaid.js" defer></script>



  <script src="/js/third-party/pace.js" defer></script>


  




  

  <script class="next-config" data-name="enableMath" type="application/json">false</script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.9/katex.min.css" integrity="sha256-UF1fgpAiu3tPJN/uCqEUHNe7pnr+QR0SQDNfgglgtcM=" crossorigin="anonymous">


  <script src="https://cdnjs.cloudflare.com/ajax/libs/quicklink/2.3.0/quicklink.umd.js" integrity="sha256-yvJQOINiH9fWemHn0vCA5lsHWJaHs6/ZmO+1Ft04SvM=" crossorigin="anonymous" defer></script>
  <script class="next-config" data-name="quicklink" type="application/json">{"enable":true,"home":true,"archive":true,"delay":true,"timeout":3000,"priority":true,"url":"http://example.com/posts/af92fc3c/"}</script>
  <script src="/js/third-party/quicklink.js" defer></script>

  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">ghost-him|🏠个人博客</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">个人博客</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-主页"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>主页</a></li><li class="menu-item menu-item-分类"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-归档"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-关于"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-捐赠"><a href="/donate/" rel="section"><i class="fa fa-heart fa-fw"></i>捐赠</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80"><span class="nav-number">1.</span> <span class="nav-text">深度学习基础</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%9A%84%E5%8F%91%E5%B1%95%E8%BF%87%E7%A8%8B"><span class="nav-number">1.1.</span> <span class="nav-text">深度学习的发展过程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8F%91%E5%B1%95%E7%9A%84%E4%B8%89%E4%B8%AA%E6%99%BA%E8%83%BD%E5%B1%82%E9%9D%A2"><span class="nav-number">1.1.1.</span> <span class="nav-text">计算机发展的三个智能层面</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E4%B8%8E%E5%85%B6%E4%BB%96%E9%A2%86%E5%9F%9F%E7%9A%84%E7%BB%93%E5%90%88"><span class="nav-number">1.1.2.</span> <span class="nav-text">人工智能与其他领域的结合</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E7%9A%84%E5%BA%94%E7%94%A8"><span class="nav-number">1.1.3.</span> <span class="nav-text">人工智能的应用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%EF%BC%8C%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%8C%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="nav-number">1.1.4.</span> <span class="nav-text">人工智能，机器学习，深度学习的关系</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-number">1.1.5.</span> <span class="nav-text">实现人工智能的方法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%9F%A5%E8%AF%86%E5%B7%A5%E7%A8%8B-vs-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0"><span class="nav-number">1.1.5.1.</span> <span class="nav-text">知识工程 vs 机器学习</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%93%E5%AE%B6%E7%B3%BB%E7%BB%9F"><span class="nav-number">1.1.6.</span> <span class="nav-text">专家系统</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0"><span class="nav-number">1.1.7.</span> <span class="nav-text">机器学习</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89"><span class="nav-number">1.1.7.1.</span> <span class="nav-text">定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%9A%84%E4%B8%89%E8%A6%81%E7%B4%A0"><span class="nav-number">1.1.7.2.</span> <span class="nav-text">机器学习的三要素</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%A8%A1%E5%9E%8B"><span class="nav-number">1.1.7.2.1.</span> <span class="nav-text">模型</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%AD%96%E7%95%A5"><span class="nav-number">1.1.7.2.2.</span> <span class="nav-text">策略</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%AE%97%E6%B3%95"><span class="nav-number">1.1.7.2.3.</span> <span class="nav-text">算法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%A0%E7%BB%9F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0"><span class="nav-number">1.1.8.</span> <span class="nav-text">传统机器学习与深度学习</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BC%A0%E7%BB%9F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0"><span class="nav-number">1.1.8.1.</span> <span class="nav-text">传统机器学习</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0"><span class="nav-number">1.1.8.2.</span> <span class="nav-text">深度学习</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%91%E7%8E%87%E5%AD%A6%E6%B4%BE%E4%B8%8E%E8%B4%9D%E5%8F%B6%E6%9C%9F%E5%AD%A6%E6%B4%BE"><span class="nav-number">1.1.9.</span> <span class="nav-text">频率学派与贝叶期学派</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Beyond-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0"><span class="nav-number">1.1.10.</span> <span class="nav-text">Beyond 深度学习</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%9A%84%E2%80%9C%E4%B8%8D%E8%83%BD%E2%80%9D"><span class="nav-number">1.2.</span> <span class="nav-text">深度学习的“不能”</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AF%84%E4%BC%B0%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%9A%84%E4%B8%A4%E4%B8%AA%E7%BB%B4%E5%BA%A6"><span class="nav-number">1.3.</span> <span class="nav-text">评估机器学习的两个维度</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B5%85%E5%B1%82%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C"><span class="nav-number">1.4.</span> <span class="nav-text">浅层神经网络</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#M-P-%E7%A5%9E%E7%BB%8F%E5%85%83"><span class="nav-number">1.4.1.</span> <span class="nav-text">M-P 神经元</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0-f"><span class="nav-number">1.4.1.1.</span> <span class="nav-text">激活函数 f</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Sigmoid-%E5%87%BD%E6%95%B0"><span class="nav-number">1.4.1.1.1.</span> <span class="nav-text">Sigmoid 函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8F%8C%E6%9E%81%E6%80%A7-S-%E5%87%BD%E6%95%B0-tanh"><span class="nav-number">1.4.1.1.2.</span> <span class="nav-text">双极性 S 函数 (tanh)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#ReLU-%E4%BF%AE%E6%AD%A3%E7%BA%BF%E6%80%A7%E5%8D%95%E5%85%83"><span class="nav-number">1.4.1.1.3.</span> <span class="nav-text">ReLU 修正线性单元</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Leaky-ReLU"><span class="nav-number">1.4.1.1.4.</span> <span class="nav-text">Leaky ReLU</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%95%E5%B1%82%E6%84%9F%E7%9F%A5%E5%99%A8"><span class="nav-number">1.4.2.</span> <span class="nav-text">单层感知器</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B7%B1%E5%B1%82%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C"><span class="nav-number">1.5.</span> <span class="nav-text">深层神经网络</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E5%B1%82%E6%84%9F%E7%9F%A5%E5%99%A8"><span class="nav-number">1.5.1.</span> <span class="nav-text">多层感知器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%87%E6%9C%89%E9%80%BC%E8%BF%91%E5%AE%9A%E7%90%86"><span class="nav-number">1.5.1.1.</span> <span class="nav-text">万有逼近定理</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E6%AF%8F%E4%B8%80%E5%B1%82%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="nav-number">1.5.2.</span> <span class="nav-text">神经网络每一层的作用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%BD%E5%BA%A6%E4%B8%8E%E6%B7%B1%E5%BA%A6"><span class="nav-number">1.5.3.</span> <span class="nav-text">宽度与深度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%9A%84%E5%8F%82%E6%95%B0%E5%AD%A6%E4%B9%A0%EF%BC%9A%E8%AF%AF%E5%B7%AE%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD"><span class="nav-number">1.5.4.</span> <span class="nav-text">神经网络的参数学习：误差反向传播</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A2%AF%E5%BA%A6%E4%B8%8E%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D"><span class="nav-number">1.5.5.</span> <span class="nav-text">梯度与梯度下降</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E5%B1%82%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%9A%84%E9%97%AE%E9%A2%98%EF%BC%9A%E6%A2%AF%E5%BA%A6%E6%B6%88%E5%A4%B1"><span class="nav-number">1.5.6.</span> <span class="nav-text">多层神经网络的问题：梯度消失</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%90%E5%B1%82%E9%A2%84%E8%AE%AD%E7%BB%83"><span class="nav-number">1.5.7.</span> <span class="nav-text">逐层预训练</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%97%E9%99%90%E7%8E%BB%E5%B0%94%E5%85%B9%E6%9B%BC%E6%9C%BA%E5%92%8C%E8%87%AA%E7%BC%96%E7%A0%81%E5%99%A8"><span class="nav-number">1.5.7.1.</span> <span class="nav-text">受限玻尔兹曼机和自编码器</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%87%AA%E7%BC%96%E7%A0%81%E5%99%A8"><span class="nav-number">1.5.7.1.1.</span> <span class="nav-text">自编码器</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8F%97%E9%99%90%E7%8E%BB%E5%B0%94%E5%85%B9%E6%9B%BC%E6%9C%BA"><span class="nav-number">1.5.7.1.2.</span> <span class="nav-text">受限玻尔兹曼机</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%B7%B1%E5%BA%A6%E4%BF%A1%E5%BF%B5%E7%BD%91%E7%BB%9C-DBN"><span class="nav-number">1.5.7.1.3.</span> <span class="nav-text">深度信念网络 (DBN)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%80%E8%88%AC%E7%8E%BB%E5%B0%94%E5%85%B9%E6%9B%BC%E6%9C%BA"><span class="nav-number">1.5.7.1.4.</span> <span class="nav-text">一般玻尔兹曼机</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%87%AA%E7%BC%96%E7%A0%81%E5%99%A8-vs-%E5%8F%97%E9%99%90%E7%8E%BB%E5%B0%94%E5%85%B9%E6%9B%BC%E6%9C%BA"><span class="nav-number">1.5.7.2.</span> <span class="nav-text">自编码器 vs 受限玻尔兹曼机</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#DNN"><span class="nav-number">1.5.8.</span> <span class="nav-text">DNN</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%87%AA%E7%BC%96%E7%A0%81%E5%99%A8%E7%9A%84%E5%8F%98%E7%A7%8D"><span class="nav-number">1.5.9.</span> <span class="nav-text">自编码器的变种</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%87%E6%8B%9F%E5%90%88%E4%B8%8E%E6%AC%A0%E6%8B%9F%E5%90%88"><span class="nav-number">1.5.10.</span> <span class="nav-text">过拟合与欠拟合</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B7%B1%E5%B1%82%E7%BD%91%E7%BB%9C%E7%9A%84%E5%B1%80%E9%83%A8%E6%9E%81%E5%B0%8F%E5%80%BC%E4%BA%A7%E7%94%9F%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="nav-number">1.5.11.</span> <span class="nav-text">深层网络的局部极小值产生的原因</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%90%E5%B1%82%E9%A2%84%E8%AE%AD%E7%BB%83%E7%9C%9F%E7%9A%84%E6%98%AF%E4%B8%BA%E4%BA%86%E6%89%BE%E5%88%B0%E6%9B%B4%E5%A5%BD%E7%9A%84%E5%B1%80%E9%83%A8%E6%9E%81%E5%B0%8F%E5%80%BC%E4%B9%88%EF%BC%9F"><span class="nav-number">1.5.12.</span> <span class="nav-text">逐层预训练真的是为了找到更好的局部极小值么？</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#pytorch%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="nav-number">2.</span> <span class="nav-text">pytorch基本操作</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%89%E8%A3%85%E5%B9%B6%E5%AF%BC%E5%85%A5pytorch%E5%BA%93"><span class="nav-number">2.1.</span> <span class="nav-text">安装并导入pytorch库</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AATensor"><span class="nav-number">2.2.</span> <span class="nav-text">创建一个Tensor</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E6%97%B6%E6%8C%87%E5%AE%9A%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">2.2.1.</span> <span class="nav-text">创建时指定数据类型</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%A9%E7%94%A8%E5%8E%9F%E6%9D%A5%E7%9A%84%E5%BC%A0%E9%87%8F%E7%94%9F%E6%88%90%E4%B8%80%E4%B8%AA%E6%96%B0%E7%9A%84%E5%BC%A0%E9%87%8F"><span class="nav-number">2.3.</span> <span class="nav-text">利用原来的张量生成一个新的张量</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E7%9A%84%E5%BC%A0%E9%87%8F%E4%B8%8E%E5%8E%9F%E6%9D%A5%E5%BC%A0%E9%87%8F%E8%AE%BE%E5%A4%87%E5%B1%9E%E6%80%A7%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B8%80%E8%87%B4"><span class="nav-number">2.3.1.</span> <span class="nav-text">创建的张量与原来张量设备属性与数据类型一致</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E7%9A%84%E5%BC%A0%E9%87%8F%E4%B8%8E%E5%8E%9F%E6%9D%A5%E5%BC%A0%E9%87%8F%E7%9A%84%E7%BB%B4%E5%BA%A6%E4%B8%80%E8%87%B4"><span class="nav-number">2.3.2.</span> <span class="nav-text">创建的张量与原来张量的维度一致</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%8C%E5%85%A8%E5%A4%8D%E5%88%B6%E4%B8%80%E4%B8%AA%E5%BC%A0%E9%87%8F"><span class="nav-number">2.3.3.</span> <span class="nav-text">完全复制一个张量</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#pytorch%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="nav-number">2.4.</span> <span class="nav-text">pytorch的操作</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#size%E5%87%BD%E6%95%B0"><span class="nav-number">2.4.1.</span> <span class="nav-text">size函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#numel-%E5%87%BD%E6%95%B0"><span class="nav-number">2.4.2.</span> <span class="nav-text">numel()函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9F%A9%E9%98%B5%E7%9B%B8%E4%B9%98"><span class="nav-number">2.4.3.</span> <span class="nav-text">矩阵相乘</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9F%A9%E9%98%B5%E8%BD%AC%E7%BD%AE"><span class="nav-number">2.4.4.</span> <span class="nav-text">矩阵转置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9F%A9%E9%98%B5%E6%8B%BC%E6%8E%A5"><span class="nav-number">2.4.5.</span> <span class="nav-text">矩阵拼接</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8pytorch%E6%9D%A5%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%BA%BF%E6%80%A7%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C"><span class="nav-number">2.5.</span> <span class="nav-text">使用pytorch来构建一个线性神经网络</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C%E5%B1%82"><span class="nav-number">2.5.1.</span> <span class="nav-text">网络层</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E6%80%A7%E5%B1%82"><span class="nav-number">2.5.1.1.</span> <span class="nav-text">线性层</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8D%B7%E7%A7%AF%E5%B1%82"><span class="nav-number">2.5.1.2.</span> <span class="nav-text">卷积层</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BE%AA%E7%8E%AF%E5%B1%82"><span class="nav-number">2.5.1.3.</span> <span class="nav-text">循环层</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0"><span class="nav-number">2.5.2.</span> <span class="nav-text">激活函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#ReLU"><span class="nav-number">2.5.2.1.</span> <span class="nav-text">ReLU</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Sigmoid"><span class="nav-number">2.5.2.2.</span> <span class="nav-text">Sigmoid</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Tanh"><span class="nav-number">2.5.2.3.</span> <span class="nav-text">Tanh</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Softmax"><span class="nav-number">2.5.2.4.</span> <span class="nav-text">Softmax</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0"><span class="nav-number">2.5.3.</span> <span class="nav-text">损失函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%A4%E5%8F%89%E7%86%B5%E6%8D%9F%E5%A4%B1"><span class="nav-number">2.5.3.1.</span> <span class="nav-text">交叉熵损失</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9D%87%E6%96%B9%E8%AF%AF%E5%B7%AE"><span class="nav-number">2.5.3.2.</span> <span class="nav-text">均方误差</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B4%9F%E5%AF%B9%E6%95%B0%E4%BC%BC%E7%84%B6%E6%8D%9F%E5%A4%B1"><span class="nav-number">2.5.3.3.</span> <span class="nav-text">负对数似然损失</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B9%B3%E6%BB%91-L1-%E6%8D%9F%E5%A4%B1"><span class="nav-number">2.5.3.4.</span> <span class="nav-text">平滑 L1 损失</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8C%E5%85%83%E4%BA%A4%E5%8F%89%E7%86%B5%E6%8D%9F%E5%A4%B1"><span class="nav-number">2.5.3.5.</span> <span class="nav-text">二元交叉熵损失</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E6%80%A7%E7%BD%91%E7%BB%9C%E6%A8%A1%E6%9D%BF"><span class="nav-number">2.5.4.</span> <span class="nav-text">线性网络模板</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8pytorch%E6%9E%84%E5%BB%BA%E6%97%A0%E9%9A%90%E5%B1%82%E7%BD%91%E7%BB%9C%EF%BC%8C%E5%8D%95%E9%9A%90%E5%B1%82%E7%BD%91%E7%BB%9C%EF%BC%8C%E5%8F%8C%E9%9A%90%E5%B1%82%E7%BD%91%E7%BB%9C"><span class="nav-number">2.5.4.1.</span> <span class="nav-text">使用pytorch构建无隐层网络，单隐层网络，双隐层网络</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AF%BE%E5%90%8E%E4%BD%9C%E4%B8%9A"><span class="nav-number">3.</span> <span class="nav-text">课后作业</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E7%BB%83%E4%B9%A0"><span class="nav-number">3.1.</span> <span class="nav-text">代码练习</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%97%AE%E9%A2%98%E5%9B%9E%E7%AD%94"><span class="nav-number">3.2.</span> <span class="nav-text">问题回答</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#AlexNet%E6%9C%89%E5%93%AA%E4%BA%9B%E7%89%B9%E7%82%B9%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8F%AF%E4%BB%A5%E2%BD%90LeNet%E5%8F%96%E5%BE%97%E6%9B%B4%E5%A5%BD%E7%9A%84%E6%80%A7%E8%83%BD%EF%BC%9F"><span class="nav-number">3.2.1.</span> <span class="nav-text">AlexNet有哪些特点？为什么可以⽐LeNet取得更好的性能？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0%E6%9C%89%E5%93%AA%E4%BA%9B%E4%BD%9C%E2%BD%A4%EF%BC%9F"><span class="nav-number">3.2.2.</span> <span class="nav-text">激活函数有哪些作⽤？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A2%AF%E5%BA%A6%E6%B6%88%E5%A4%B1%E7%8E%B0%E8%B1%A1%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">3.2.3.</span> <span class="nav-text">梯度消失现象是什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A5%9E%E7%BB%8F%E2%BD%B9%E7%BB%9C%E6%98%AF%E6%9B%B4%E5%AE%BD%E5%A5%BD%E8%BF%98%E6%98%AF%E6%9B%B4%E6%B7%B1%E5%A5%BD%EF%BC%9F"><span class="nav-number">3.2.4.</span> <span class="nav-text">神经⽹络是更宽好还是更深好？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E2%BD%A4Softmax"><span class="nav-number">3.2.5.</span> <span class="nav-text">为什么要使⽤Softmax?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SGD-%E5%92%8C-Adam-%E5%93%AA%E4%B8%AA%E6%9B%B4%E6%9C%89%E6%95%88%EF%BC%9F"><span class="nav-number">3.2.6.</span> <span class="nav-text">SGD 和 Adam 哪个更有效？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%96%91%E9%97%AE"><span class="nav-number">3.3.</span> <span class="nav-text">疑问</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="ghost-him" src="http://kodo.ghost-him.com/head.jpg">
    <p class="site-author-name" itemprop="name">ghost-him</p>
    <div class="site-description" itemprop="description">爱代码，爱生活！</div>
  </div>
    <div class="site-state-wrap animated">
      <nav class="site-state">
          <div class="site-state-item site-state-posts">
            <a href="/archives/">
              <span class="site-state-item-count">129</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>
          <div class="site-state-item site-state-categories">
              <a href="/categories/">
              <span class="site-state-item-count">31</span>
              <span class="site-state-item-name">分类</span>
              </a>
            
          </div>
          <div class="site-state-item site-state-tags">
              <span class="site-state-item-count">21</span>
              <span class="site-state-item-name">标签</span>
          </div>
      </nav>
    </div>
    <div class="links-of-author animated">
        <span class="links-of-author-item">
          <a href="https://github.com/ghost-him" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;ghost-him" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
        </span>
        <span class="links-of-author-item">
          <a href="mailto:ghost-him@outlook.com" title="E-Mail → mailto:ghost-him@outlook.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
        </span>
    </div>
    <div class="cc-license animated" itemprop="license">
      <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/zh-CN" class="cc-opacity" rel="noopener" target="_blank"><img src="https://cdnjs.cloudflare.com/ajax/libs/creativecommons-vocabulary/2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a>
    </div>
  <iframe
    frameborder="no"
    border="0"
    marginwidth="0"
    marginheight="0"
    width="330"
    height="270"
    src="//music.163.com/outchain/player?type=0&id=8244788626&auto=0&height=430"></iframe>
        </div>
      </div>
    </div>

    
    <div class="sidebar-inner sidebar-blogroll">
      <div class="links-of-blogroll animated">
        <div class="links-of-blogroll-title"><i class="fa fa-globe fa-fw"></i>
          链接
        </div>
        <ul class="links-of-blogroll-list">
            <li class="links-of-blogroll-item">
              <a href="https://alan-blog.netlify.app/" title="https:&#x2F;&#x2F;alan-blog.netlify.app&#x2F;" rel="noopener" target="_blank">alan</a>
            </li>
        </ul>
      </div>
    </div>
        <div class="pjax">
        </div>
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/posts/af92fc3c/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="http://kodo.ghost-him.com/head.jpg">
      <meta itemprop="name" content="ghost-him">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ghost-him|🏠个人博客">
      <meta itemprop="description" content="爱代码，爱生活！">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="深度学习：算法到实战学习笔记01 | ghost-him|🏠个人博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          深度学习：算法到实战学习笔记01
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-05-23 16:52:16" itemprop="dateCreated datePublished" datetime="2024-05-23T16:52:16+08:00">2024-05-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-07-04 14:04:32" itemprop="dateModified" datetime="2024-07-04T14:04:32+08:00">2024-07-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">深度学习学习笔记</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><p>笔记内容来源：<a target="_blank" rel="noopener" href="https://study.163.com/course/courseMain.htm?share=1&shareId=1444565553&courseId=1006498024&_trace_c_p_k2_=8d7d1d5450d84b26a33554ba7d340ab2">视频</a></p>
<span id="more"></span>

<h1 id="深度学习基础"><a href="#深度学习基础" class="headerlink" title="深度学习基础"></a>深度学习基础</h1><h2 id="深度学习的发展过程"><a href="#深度学习的发展过程" class="headerlink" title="深度学习的发展过程"></a>深度学习的发展过程</h2><h3 id="计算机发展的三个智能层面"><a href="#计算机发展的三个智能层面" class="headerlink" title="计算机发展的三个智能层面"></a>计算机发展的三个智能层面</h3><ul>
<li>计算智能：能存储，会计算。解决问题的方法主要基于暴力穷举。</li>
<li>感知智能：拥有人类一样的视觉，听觉，触觉等感知能力。</li>
<li>谁知智能：计算机可以拥有概念，意识，观念。</li>
</ul>
<h3 id="人工智能与其他领域的结合"><a href="#人工智能与其他领域的结合" class="headerlink" title="人工智能与其他领域的结合"></a>人工智能与其他领域的结合</h3><ul>
<li>人工智能+金融：支付宝的芝麻信用</li>
<li>人工智能+内容创作：<code>gpt</code></li>
<li>人工智能+机器人：机械臂</li>
</ul>
<h3 id="人工智能的应用"><a href="#人工智能的应用" class="headerlink" title="人工智能的应用"></a>人工智能的应用</h3><ul>
<li>计算机视觉<ul>
<li>应用：人脸识别，图像分类，目标检测，图像分割等。</li>
</ul>
</li>
<li>语音技术<ul>
<li>语音合成，声纹识别等</li>
</ul>
</li>
<li>自然语言处理<ul>
<li>机器翻译，知识图谱等</li>
</ul>
</li>
</ul>
<h3 id="人工智能，机器学习，深度学习的关系"><a href="#人工智能，机器学习，深度学习的关系" class="headerlink" title="人工智能，机器学习，深度学习的关系"></a>人工智能，机器学习，深度学习的关系</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">人工智能 &gt; 机器学习 &gt; 深度学习</span><br></pre></td></tr></table></figure>

<ul>
<li>人工智能是一个领域，是一个目标。</li>
<li>机器学习是实现人工智能的一个方法。</li>
<li>深度学习机器学习众多方法中的一个方法。</li>
</ul>
<h3 id="实现人工智能的方法"><a href="#实现人工智能的方法" class="headerlink" title="实现人工智能的方法"></a>实现人工智能的方法</h3><table>
<thead>
<tr>
<th>ai 数理基础</th>
<th>逻辑：知识表达与推理</th>
<th>概率：模型，策略，算法</th>
</tr>
</thead>
<tbody><tr>
<td>主流技术</td>
<td>逻辑推理，知识工程</td>
<td>机器学习</td>
</tr>
<tr>
<td>Ai 学派</td>
<td>符号主义（自上而下）</td>
<td>贝叶斯：对事件发生的可能性进行概率推理（自上而下+自下而上）；联结主义：模拟脑结构：使用概率矩阵来识别和归纳模式（自下而上+自上而下）</td>
</tr>
<tr>
<td>代表方法</td>
<td>定理证明机，专家系统</td>
<td>朴素贝叶斯，神经网络，隐马尔科</td>
</tr>
</tbody></table>
<h4 id="知识工程-vs-机器学习"><a href="#知识工程-vs-机器学习" class="headerlink" title="知识工程 vs 机器学习"></a>知识工程 vs 机器学习</h4><ul>
<li><p>知识工程：基于手工设计规则，结果容易解释，系统构建费时费力，难以保证一致性和准确性</p>
</li>
<li><p>机器学习：基于数据自动学习，结果可能不易解释，提高信息处理的效率，减少人工规则主观性，可信度高</p>
</li>
</ul>
<h3 id="专家系统"><a href="#专家系统" class="headerlink" title="专家系统"></a>专家系统</h3><p>机器根据专家定义的知识和经验，进行推理和判断，从而模拟人类专家的决策过程来解决问题。</p>
<p>专家系统的缺点：定制一个专家系统耗时耗力，而且专家系统的准确度完全依赖于人类专家。</p>
<p>常见的专家系统有：调查问卷</p>
<p>在定制专家系统时，对于每一个问题，都要确定其语义概念；对于一个问题的选项，要确定其对于目标问题的含义。</p>
<h3 id="机器学习"><a href="#机器学习" class="headerlink" title="机器学习"></a>机器学习</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><ul>
<li>常用定义：计算机系统能够利用经验提高自身的性能</li>
<li>可操作定义：机器学习本质是一个基于经验数据的函数估计问题</li>
<li>统计学定义：提取重要模式，趋势，并理解数据，即从数据中学习</li>
</ul>
<p>机器学习学的是有意义的模式，有规律的模式，比如：预测天气，预测比赛获胜的概率；而不是无意义的模式，比如：下一次抛硬币是正面还是反面。</p>
<h4 id="机器学习的三要素"><a href="#机器学习的三要素" class="headerlink" title="机器学习的三要素"></a>机器学习的三要素</h4><h5 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h5><p>模型是机器学习系统的核心，它是用来表示数据和预测结果之间关系的数学结构或函数。模型可以看作是一个函数，它接受输入数据并输出预测结果。</p>
<p>常见的模型有：</p>
<ul>
<li>线性模型：线性回归，逻辑回归。</li>
<li>非线性模型：决策树，支持向量机，神经网络。</li>
<li>概率模型：高斯混合模型，隐马尔可夫模型。</li>
</ul>
<p>模型的作用是从数据中学习到有用的模式或规律，并能够对新的数据进行预测或分类。</p>
<p>在<code>pytorch</code>中，模型代表神经网络的模型。</p>
<p>模型可以分为以下几种类别：</p>
<ul>
<li>以数据标记分类<ul>
<li>监督学习模型</li>
<li>无监督学习模型</li>
<li>半监督学习</li>
<li>强化学习</li>
</ul>
</li>
<li>以数据分布分类<ul>
<li>参数模型</li>
<li>非参数模型</li>
</ul>
</li>
<li>以建模对象分类<ul>
<li>判别模型</li>
<li>生成模型</li>
</ul>
</li>
</ul>
<p>监督学习模型：样本具有标记。从数据中学习标记分界面，适用于预测数据标记</p>
<p>无监督学习模型：样本没有标记。从数据中学习模式，适用于描述数据。</p>
<p>半监督学习模型：部分数据标记已知。是监督与无监督学习的混合。</p>
<p>半监督学习模型的出发点是标记样本难以获取，无标记样本相对廉价。因此，其假设未标记样本与标记样本独立同分布，包含关于数据分布的重要信息。（聚类假设与流形假设）</p>
<p>强化学习模型：数据标记未知，但知道与输出目标相关的反馈。适用决策类问题。</p>
<p>强化学习模型会使用未标记的数据，但可以知道离目标越来越近还是越来越远（奖励反馈）。</p>
<p>参数模型：对数据分布进行假设，待求解的数据模式可以用一组有限且固定数目的参数进行刻画。例：线性回归模型。</p>
<p>非参数模型：不对数据分布进行假设，数据的所有统计特性都来源于数据本身。例：k 近邻，决策树，随机森林。</p>
<p>在参数模型与非参数模型中，</p>
<ul>
<li>参数是指数据分布的参数，而不是模型的参数。</li>
<li>非参数模型的时空复杂度一般比参数模型大得多。</li>
<li>参数模型的模型参数固定，非参数模型是自适应的，模型参数随样本变化而变化</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>参数模型</th>
<th>非参数模型</th>
</tr>
</thead>
<tbody><tr>
<td>优点</td>
<td>数据需求少，训练快速</td>
<td>对数据适应性强，可以拟合不同的函数形式</td>
</tr>
<tr>
<td>缺点</td>
<td>模型复杂度有限，与真实目标函数拟合度小</td>
<td>数据需求大，容易过拟合</td>
</tr>
</tbody></table>
<p>判别模型：输入特征 X，直接预测出最可能的 Y。专注于区分不同类别的数据。例：SVM，逻辑回归，条件随机场，决策树。</p>
<p>生成模型：对输入 X 与输出 Y 的联合分布 $P(X,Y)$ 建模。这种模型不仅可以进行分类，也可以生成类似于训练数据的新数据。例：朴素贝叶斯，隐马尔可夫，马尔科夫随机场。</p>
<h5 id="策略"><a href="#策略" class="headerlink" title="策略"></a>策略</h5><p>策略，也称为目标函数或损失函数，是用来评估模型性能的标准。它定义了模型输出与实际结果之间的差异，并指导模型的优化过程。</p>
<p>常见的策略有：</p>
<ul>
<li>均方误差：用于回归问题，衡量预测值与真实值之间的平均平方差。</li>
<li>交叉熵损失：用于分类问题，衡量预测概率分布与真实分布之间的差异。</li>
<li>二元交叉熵损失：用于二分类任务，计算二元交叉熵损失。</li>
</ul>
<p>损失函数的作用是量化模型的预测误差，并通过最小化损失函数来优化模型参数，从而提高模型的预测准确性。</p>
<p>在<code>pytorch</code>中，策略代表使用的损失函数。</p>
<ul>
<li>策略设计<ul>
<li>无免费午餐定理<ul>
<li>当考虑在所有问题上的平均性能时，任意两个模型都是相同的：脱离了具体的问题，则无意义</li>
<li>没有任何一个模型可以在所有的学习任务里表现最好</li>
</ul>
</li>
<li>奥卡姆剃刀原理<ul>
<li>如无必要，勿增实体：简单有效原理</li>
<li>如果多种模型能够同等程度地符合一个问题的观测结果，应该选择其中使用假设最少的那个</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h5><p>算法是指优化模型参数的具体方法或步骤。它是训练模型的过程，通过不断调整模型参数来最小化损失函数。</p>
<p>常见的算法有：</p>
<ul>
<li>梯度下降：一种迭代优化算法，用于最小化损失函数。例如：随机梯度下降（SGD）。</li>
<li>牛顿法：一种二阶优化算法，利用损失函数的二阶导数信息进行优化。</li>
<li>遗传算法：一种基于自然选择和遗传机制的优化算法，适用于复杂的优化问题。</li>
</ul>
<p>算法的作用是通过优化过程。</p>
<p>在<code>pytorch</code>中，算法代表使用的优化器。</p>
<h3 id="传统机器学习与深度学习"><a href="#传统机器学习与深度学习" class="headerlink" title="传统机器学习与深度学习"></a>传统机器学习与深度学习</h3><h4 id="传统机器学习"><a href="#传统机器学习" class="headerlink" title="传统机器学习"></a>传统机器学习</h4><p>特点：人工设计特征。</p>
<p>处理流程：</p>
<ol>
<li>预处理：经过数据的预处理，如去噪声等。（人工）</li>
<li>特征提取：从原始数据中提取一些有效的特征。（人工）</li>
<li>特征转换：对特征进行一定的加工，比降维与升维。（人工）</li>
<li>预测识别（机器）</li>
</ol>
<h4 id="深度学习"><a href="#深度学习" class="headerlink" title="深度学习"></a>深度学习</h4><p>处理流程：</p>
<ol>
<li>输入</li>
<li>浅层的特征（机器）</li>
<li>深层的特征（机器）</li>
<li>预测识别（机器）</li>
</ol>
<h3 id="频率学派与贝叶期学派"><a href="#频率学派与贝叶期学派" class="headerlink" title="频率学派与贝叶期学派"></a>频率学派与贝叶期学派</h3><p>频率学派</p>
<ul>
<li>关注可独立重复的随机试验中单个事件发生的频率</li>
<li>可能性：可作发生频率的极限值-&gt;重复试验次数趋近于无穷大时，事件发生的频率会收敛到真实的概率</li>
<li>假设概率是客观存在且固定的</li>
<li>模型参数是唯一的，需要从有限有观测数据中估计参数值</li>
</ul>
<p>方法：统计机器学习：设计不同概率模型去拟合数据背后的规律-&gt;用拟合出的规律去推断和预测未知的结果（线性回归，决策树，支持向量机）</p>
<p>贝叶斯学派</p>
<ul>
<li>关注随机事件的可信程序，如天气预报明天下雨的概率</li>
<li>可能性：假设+数据：数据的作用是对初始假设做出修正，使观察者对概率的主观认识更接近客观实际</li>
<li>模型参数本身是随机变量，需求估计参数的整个概率分布</li>
</ul>
<p>方法：概率图模型：根据数据+变量的先驱分布，同时推断每个变量以及变量之间关系的后验分布（隐马尔科夫，条件随机场，主题模型）</p>
<h3 id="Beyond-深度学习"><a href="#Beyond-深度学习" class="headerlink" title="Beyond 深度学习"></a>Beyond 深度学习</h3><p>统计机器学习：寻找相关性</p>
<p>但是，相关性不可靠：Yule-Simpson 悖论。相关关系可能由于 context 等混杂因素而改变。</p>
<p>相关性与因果性：因果性&#x3D;相关性+忽略的因素。</p>
<p>因果性：排队其他因素后，Y 仅由 X 影响<br>相关性：Y 发生时往往伴随着 X</p>
<ul>
<li>群体智能</li>
</ul>
<p>例：在看验证码，图像检测，图像分割</p>
<h2 id="深度学习的“不能”"><a href="#深度学习的“不能”" class="headerlink" title="深度学习的“不能”"></a>深度学习的“不能”</h2><p>算法输出不稳定，容易被”攻击”</p>
<ul>
<li>模型复杂度高，难以纠错与调试</li>
<li>模型层级复合程序高，参数不透明</li>
<li>端到端的训练方式对数据依赖性强，模型增量性差<ul>
<li>$Test loss - training loss &lt;&#x3D; \sqrt{\frac{N}{m}}$</li>
<li><code>m</code>: 训练样本，<code>N</code>：模型有效容量</li>
<li>当样本数据量小的时候，深度学习无法体现强大的拟合能力</li>
</ul>
</li>
<li>专注直观感知类问题，对开放性推理问题无能为力</li>
<li>人类知识无法有效引入进行监督，机器偏见难以避免<ul>
<li>算法依赖于大数据，但数据不是中立的：来源社会，存在不平等</li>
</ul>
</li>
</ul>
<p>解释性的三个层次</p>
<ol>
<li>找得到：出了问题可以快速纠错</li>
<li>看得懂：双向：算法可以被人的知识体系理解+利用和结合人类的知识</li>
<li>留得下：越学越聪明</li>
</ol>
<h2 id="评估机器学习的两个维度"><a href="#评估机器学习的两个维度" class="headerlink" title="评估机器学习的两个维度"></a>评估机器学习的两个维度</h2><ul>
<li>准确性</li>
<li>解释性</li>
</ul>
<p>当前，深度学习的准确性很高，解释性很低。</p>
<p>提高解释性的可能的方法：</p>
<ul>
<li>深度学习+图谱</li>
<li>数据+知识</li>
</ul>
<h2 id="浅层神经网络"><a href="#浅层神经网络" class="headerlink" title="浅层神经网络"></a>浅层神经网络</h2><h3 id="M-P-神经元"><a href="#M-P-神经元" class="headerlink" title="M-P 神经元"></a>M-P 神经元</h3><ul>
<li>多输入信号进行累加 $\sum_{i}x_{i}$</li>
<li>权值 $w_{i}$ 正负模拟兴奋\抑制，大小模拟强度</li>
<li>输入和走过阈值 $\theta$，神经元被激活 (fire)</li>
<li>输出 $y &#x3D; f(\sum_{i&#x3D;1}^{n}w_{i}x_{i}-\theta)$</li>
<li>其神经元的权重预先设置，无法学习</li>
</ul>
<h4 id="激活函数-f"><a href="#激活函数-f" class="headerlink" title="激活函数 f"></a>激活函数 f</h4><p> 神经元继续传递信息，产生新连接的概率（超过阈值被激活，但不一定被传递）</p>
<p>如果没有激活函数，相当于矩阵相乘：多层与一层一样，只能拟合线性函数。</p>
<p>常见的激活函数：</p>
<ul>
<li>线性函数</li>
<li>斜面函数</li>
<li>阈值函数</li>
<li>符号函数</li>
<li><code>sigmoid</code> 函数 （s 函数）</li>
</ul>
<h5 id="Sigmoid-函数"><a href="#Sigmoid-函数" class="headerlink" title="Sigmoid 函数"></a><code>Sigmoid</code> 函数</h5><p>$$<br>\sigma (z)&#x3D; \frac{1}{1+e^{-z}}<br>$$</p>
<p>缺点：</p>
<ol>
<li>容易饱和</li>
<li>输出不对称（只能输出在 <code>(0, 1)</code> 之间）</li>
</ol>
<p>针对第一个问题，提出了 <code>ReLU</code> 修正线性单元<br>针对第二个问题，提出了双极 S 性函数（tanh）</p>
<h5 id="双极性-S-函数-tanh"><a href="#双极性-S-函数-tanh" class="headerlink" title="双极性 S 函数 (tanh)"></a>双极性 S 函数 (tanh)</h5><p>$$<br>tanh(x)&#x3D;2sigmoid(2x)-1&#x3D;\frac{e^{z}-e^{-z}}{e^{z}+e^{-z}}<br>$$</p>
<p>该函数的输出可以出现在 <code>(-1, 1)</code> 之间</p>
<h5 id="ReLU-修正线性单元"><a href="#ReLU-修正线性单元" class="headerlink" title="ReLU 修正线性单元"></a>ReLU 修正线性单元</h5><p>$$<br>relu(z)&#x3D;max(0,z)<br>$$</p>
<p>优点：当输入大于 0 时，其斜率可以保持为 1<br>缺点：当输入是一个很大的负值时，其结果永远是 0，无法输出一个正值。此时，相当于神经元已经失效了。</p>
<p>对于该缺点，提出了 <code>Leaky ReLU</code> 函数</p>
<h5 id="Leaky-ReLU"><a href="#Leaky-ReLU" class="headerlink" title="Leaky ReLU"></a>Leaky ReLU</h5><p>$$<br>leakyrelu(z)&#x3D;max(0.01z,z)<br>$$</p>
<p>负轴不恒为 0，可以让其跳出负值。</p>
<h3 id="单层感知器"><a href="#单层感知器" class="headerlink" title="单层感知器"></a>单层感知器</h3><ul>
<li><p>单层感知器是首个可以学习的人工神经网络</p>
</li>
<li><p>单层感知器被证明，无法解决异或问题。</p>
</li>
</ul>
<h2 id="深层神经网络"><a href="#深层神经网络" class="headerlink" title="深层神经网络"></a>深层神经网络</h2><h3 id="多层感知器"><a href="#多层感知器" class="headerlink" title="多层感知器"></a>多层感知器</h3><p>通过组合单层感知器，即可得到多层感知器。</p>
<h4 id="万有逼近定理"><a href="#万有逼近定理" class="headerlink" title="万有逼近定理"></a>万有逼近定理</h4><p>如果一个隐层包含足够多的神经元，三层前馈神经网络（输入，隐层-输出）能以任意精度逼近任意预定的连续函数。</p>
<p>线性分类任务组合后可以解决非线性分类任务的原因：第一层感知器将输入进行空间变换，将变换后的图像输入给第二层，第二层看到的就成了一个线性可分的问题。</p>
<ul>
<li>双隐层感知器逼近非连续函数：当隐层足够宽时，双隐层感知器（输入-隐层 1-隐层 2-输出）可以逼近任意非连续函数：可以解决任何复杂的分类问题。</li>
</ul>
<table>
<thead>
<tr>
<th>结构</th>
<th>决策区域类型</th>
<th>异或问题</th>
</tr>
</thead>
<tbody><tr>
<td>无隐层</td>
<td>由一超平面分成两个</td>
<td>无</td>
</tr>
<tr>
<td>单隐层</td>
<td>开凸区域或闭凸区域</td>
<td>可以解决，但是要求分界面是连续的</td>
</tr>
<tr>
<td>双隐层</td>
<td>任意形状（其复杂度由单元数目确定）</td>
<td>可以解决，分界面也可以是不连续的</td>
</tr>
</tbody></table>
<h3 id="神经网络每一层的作用"><a href="#神经网络每一层的作用" class="headerlink" title="神经网络每一层的作用"></a>神经网络每一层的作用</h3><p>每一层的数学公式<br>$$<br>\vec{y}&#x3D;a(W* \vec{x}+b)<br>$$<br>完成：</p>
<ul>
<li>升维&#x2F;降维（$W*x$）</li>
<li>放大&#x2F;缩小（$W*x$）</li>
<li>旋转（$W*x$）</li>
<li>平移（$+b$）</li>
<li>弯曲（$a()$）</li>
</ul>
<p>训练数据的作用：让神经网络去选择一种线性或非线性的一种变换。</p>
<ul>
<li>神经网络学习如何利用矩阵的线性变换加激活函数的非线性变换，将原始输入空间投影到线性可分的空间去分类&#x2F;回归。</li>
<li>增加节点数：增加维度，即增加线性转移能力。</li>
<li>增加层数：增加激活函数的次数，即增加非线性转移次数。</li>
</ul>
<h3 id="宽度与深度"><a href="#宽度与深度" class="headerlink" title="宽度与深度"></a>宽度与深度</h3><ul>
<li><p>在神经元总数相当的情况下，增加网络深度可以比增加宽度带来更强的网络表示能力：产生更多的线性区域</p>
</li>
<li><p>深度和宽度对函数复杂度的贡献是不同的，深度的贡献是指数增长的，而宽度的贡献是线性的。</p>
</li>
</ul>
<h3 id="神经网络的参数学习：误差反向传播"><a href="#神经网络的参数学习：误差反向传播" class="headerlink" title="神经网络的参数学习：误差反向传播"></a>神经网络的参数学习：误差反向传播</h3><ul>
<li>多层神经网络可以看成是一个复合的非线性多元函数</li>
</ul>
<p>$$<br>F(x)&#x3D;f_{n}(…f_{3}(f_{2}(f_{1}(x)<em>\theta_{1}+b)</em>\theta_{2}+b)…)<br>$$</p>
<ul>
<li>给定训练数据，希望损失尽可能小</li>
</ul>
<p>训练的过程：输入一个数据，经过神经网络的逐层传播，得出一个结果，再和原本的输入做比较得出一个误差。再将该误差进行一个回传，再利用梯度来更新这个神经元。</p>
<h3 id="梯度与梯度下降"><a href="#梯度与梯度下降" class="headerlink" title="梯度与梯度下降"></a>梯度与梯度下降</h3><p>导数：</p>
<ul>
<li><p>函数值在某一点沿自变量正方向的变化率</p>
</li>
<li><p>多元函数在每个点可以有多个方向</p>
</li>
<li><p>每个方向都可以计算导数，这种导数称为方向导数。</p>
</li>
</ul>
<p>梯度：</p>
<ul>
<li>梯度是一个向量<ul>
<li>方向是最大方向导数的方向</li>
<li>模为方向导数的最大值</li>
</ul>
</li>
</ul>
<p>无约束优化：梯度下降</p>
<ul>
<li>参数沿负梯度方向更新可以使函数值下降</li>
<li>如果函数有多个极值点，则最终结果会非常依赖于初始点</li>
</ul>
<p>反向传播算法（BP算法）</p>
<ul>
<li>是训练多层前馈神经网络的核心方法。</li>
<li>整体网络的训练过程：通过前向传播计算输出，使用目标输出计算误差，然后通过反向传播计算梯度，最后更新权重和偏置。</li>
</ul>
<h3 id="多层神经网络的问题：梯度消失"><a href="#多层神经网络的问题：梯度消失" class="headerlink" title="多层神经网络的问题：梯度消失"></a>多层神经网络的问题：梯度消失</h3><p>训练神经网络的过程如下：</p>
<ol>
<li>前向传播：输入值  <code>x</code> 经过 <code>w1</code>，<code>w2</code>，…, <code>wn</code> 的计算后得到结果 <code>c </code></li>
<li>反向传播（误差通过梯度传播）</li>
</ol>
<p>通过反向传播的更新公式为：</p>
<img data-src="http://kodo.ghost-him.com/blogPicture/Pasted image 20240521145309.png">

<p>从该公式中可以知道：即使 $\frac{\partial C}{\partial b_{4}}$ 很大，但是前面相乘的值可能会很小（比如 <code>sigmoid</code> 函数接近 1 时的梯度），因此，结其最后的结果可能接近为 0，即出现梯度消息的情况。</p>
<p>因为存在梯度消息的问题，所以在训练多层神经网络时，往往是最后一层被训练的很好，但是第一层却几乎没变化。然而在最终做测试时，要使用所有层的网络。因为第一层没有被训练好，所以整体网络也没有被训练好。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">增加深度会造成梯度消息，误差无法传播的问题；多层网络容易陷入局部极值，难以训练 ` =&gt; `三层神经网络是主流，预训练，新激活函数使深度成为可能</span><br></pre></td></tr></table></figure>

<h3 id="逐层预训练"><a href="#逐层预训练" class="headerlink" title="逐层预训练"></a>逐层预训练</h3><p>原理：如果随机选择初始点会使得网络陷入不算很好的局部最优点，那么可以通过人为的选择一个不错的初始点来让网络达到一个很好的性能（即使其收敛的点不是全局最优点）。</p>
<p>优点：</p>
<ol>
<li>解会更加收敛一些，不容易进入一个很差的点里</li>
<li>训练会更快</li>
</ol>
<p>方式：</p>
<ol>
<li>先训练一层，等该层训练的差不多了以后，再加一层，该层则不再训练</li>
<li>训练第二层，等该层训练的差不多了以后，再加一层，该层则不再训练</li>
<li>…</li>
<li>训练完成</li>
</ol>
<p>作用：</p>
<ul>
<li>逐层无监督预训练使得深度网络的训练有了可能</li>
<li>其无法本质上解决梯度消失等问题</li>
</ul>
<h4 id="受限玻尔兹曼机和自编码器"><a href="#受限玻尔兹曼机和自编码器" class="headerlink" title="受限玻尔兹曼机和自编码器"></a>受限玻尔兹曼机和自编码器</h4><p>目标：解决在逐层训练时中间的隐层看不到整体网络的输出结果的情况。</p>
<h5 id="自编码器"><a href="#自编码器" class="headerlink" title="自编码器"></a>自编码器</h5><img data-src="http://kodo.ghost-him.com/blogPicture/Pasted image 20240521153054.png">

<ul>
<li><p>自编码器假设输出与输入相同，是一种尽可能复现输入信号的神经网络。</p>
</li>
<li><p>没有额外的监督信息：无标签数据，误差的来源是直接重构后信号与原输入相比得到的</p>
</li>
<li><p>自编码器一般是一个多层神经网络（最简单，三层）：</p>
<ul>
<li>训练目标是使输出层与输入层误差最小</li>
<li>中间隐层是代表输入的特征，可以最大程度上代表原输入信号</li>
</ul>
</li>
<li><p>自编码器最初用于降维，</p>
</li>
</ul>
<p>使用自编码器构建深度神经网络</p>
<img data-src="http://kodo.ghost-him.com/blogPicture/Pasted image 20240521153639.png">

<h5 id="受限玻尔兹曼机"><a href="#受限玻尔兹曼机" class="headerlink" title="受限玻尔兹曼机"></a>受限玻尔兹曼机</h5><ul>
<li><p>模型结构</p>
<ul>
<li>RBM 是两层神经网络，包含可见层 v 与隐藏层 h</li>
<li>不同层之间全连接，层内无连接，是一个二分图</li>
<li>与感知器不同，RBM 没有旷工的重构过程：<ul>
<li>输入 V ，通过 <code>p(h|v)</code> 得到隐藏层 h；输入 h，通过 <code>p(v|h)</code> 得到 v</li>
</ul>
</li>
<li>目的是让隐藏层得到的可见层 <code>v&#39;</code> 与原来的可见层 v 分布一致，从而使隐藏层作为可见层输入的特征</li>
<li>两个方向权重 w 共享，偏置不同</li>
</ul>
</li>
<li><p>条件概率建模</p>
<ul>
<li>$p(h_{i}&#x3D;1|v)&#x3D;sigm(c_{i}+W_{i}v)$</li>
<li>$p(v_{j}&#x3D;1|v)&#x3D;sigm(b_{j}+W_{j}’v)$</li>
</ul>
</li>
</ul>
<p>获得概率模型的两种方法：</p>
<ul>
<li>判别模型：直接对条件概率建模</li>
<li>深度模型：对联合概率做建模，然后使用 bs 公式算出条件概率</li>
</ul>
<p>玻尔兹曼分布-&gt;sigmoid 激活函数证明：<br>$p(h|v)&#x3D;\frac{P(h,v)}{P(v)}&#x3D;…$</p>
<p>假设标准的玻尔兹曼分布中，所有的节点是二进制变量 (0, 1)，则<br>$$<br>P(h_{j}&#x3D;1|v)&#x3D;\frac{P(h_{j}&#x3D;1|v)}{P(h_{j}&#x3D;1|v)+P(h_{j}&#x3D;0|v)}&#x3D;…&#x3D;sigmoid(b_{j}+W_{j}v)<br>$$</p>
<ul>
<li>模型求解<ul>
<li>优化目标：网络表示的概率分布与输入样本分布尽可能接近</li>
<li>可见层的 v 的似然：</li>
</ul>
</li>
</ul>
<h5 id="深度信念网络-DBN"><a href="#深度信念网络-DBN" class="headerlink" title="深度信念网络 (DBN)"></a>深度信念网络 (DBN)</h5><ul>
<li>一个 DBN 由若干个 RBM 堆叠而成，最后加一个监督层</li>
<li>训练的过程由低到高逐层训练</li>
<li>DBN vs DBM<ul>
<li>DBM 没有监督层，是若干个 RBM 直接堆叠</li>
<li>无向图模型，每两层互有反馈</li>
</ul>
</li>
</ul>
<h5 id="一般玻尔兹曼机"><a href="#一般玻尔兹曼机" class="headerlink" title="一般玻尔兹曼机"></a>一般玻尔兹曼机</h5><ul>
<li>可见层与隐层内部结点之间可连接</li>
<li>具有很强大的无监督学习能力，能够学习数据中复杂和规则</li>
<li>随机神经网络和递归神经网络的一种</li>
</ul>
<p>缺点：</p>
<ul>
<li>全连接图，复杂度很高</li>
</ul>
<h4 id="自编码器-vs-受限玻尔兹曼机"><a href="#自编码器-vs-受限玻尔兹曼机" class="headerlink" title="自编码器 vs 受限玻尔兹曼机"></a>自编码器 vs 受限玻尔兹曼机</h4><ul>
<li>结构上<ul>
<li>自编码器编码和解码函数不同</li>
<li>RBM 共享权重矩阵 w，两个偏置向量</li>
</ul>
</li>
<li>原理上：<ul>
<li>自编码器通过非线性变换学习特征，是确定的，特征值可以为任何实数</li>
<li>RBM 基于概率分布定义，高层表示为底层特征的条件概率，输出只有两种状态，用二进制表示</li>
</ul>
</li>
<li>训练优化<ul>
<li>自编码器通过最损失函数 L 化重构输入数据，直接用 BP 优化求解</li>
<li>RBM 基于最大似然，能量函数偏导无法直接计算，基于采样方法进行估计</li>
</ul>
</li>
<li>生成&#x2F;判别模型：<ul>
<li>RBM 对联合概率密度建模，是生成式模型；</li>
<li>自编码器直接对条件概率建模，是判别式模型。</li>
</ul>
</li>
</ul>
<h3 id="DNN"><a href="#DNN" class="headerlink" title="DNN"></a>DNN</h3><ul>
<li>是前馈神经网络，训练方法是 BP</li>
<li>隐层激活函数使用 ReLU-&gt;改善梯度消失</li>
<li>输出层激活函数是 softmax，目标函数是交叉熵+大量标注数据-&gt;避免了差的局部极小值</li>
<li>正则化+dropout-&gt;改善过拟合</li>
<li>没有使用逐层预训练</li>
</ul>
<h3 id="自编码器的变种"><a href="#自编码器的变种" class="headerlink" title="自编码器的变种"></a>自编码器的变种</h3><ul>
<li>正则自编码器：<ul>
<li>应用：使提取的特征表达符合某种性质</li>
</ul>
</li>
<li>稀疏自编码器：<ul>
<li>应用：提取稀疏特征表达（假设：高维而稀疏的表达是好的）</li>
</ul>
</li>
<li>去噪自编码器：<ul>
<li>应用：提取鲁棒特征表达（假设：能够对”被污染&#x2F;破坏”的原始数据编码，解码，还能恢复真正的原始数据，这样的特征才是好的）</li>
</ul>
</li>
<li>变分自编码器：<ul>
<li>原理：基于隐层特征表达空间 Z，通过解码层，生成样本。</li>
<li>非监督生成模型，与对抗式生成网络 GAN 关系密切，是深度学习-概率图模型桥梁。</li>
<li>应用：数据生成，缺失数据填补，图像超分辨率</li>
</ul>
</li>
</ul>
<h3 id="过拟合与欠拟合"><a href="#过拟合与欠拟合" class="headerlink" title="过拟合与欠拟合"></a>过拟合与欠拟合</h3><p>欠拟合：训练器的一般性质尚未被学习器学好（训练误差大）</p>
<p>解决欠拟合的思路：</p>
<ul>
<li>目标：提高模型复杂度<ul>
<li>决策树：拓展分支</li>
<li>神经网络：增加训练轮数</li>
</ul>
</li>
</ul>
<p>过拟合：学习器把训练集特点当做样本的一般特点（训练误差小，测试误差大）</p>
<p>解决过拟合的思路：</p>
<ul>
<li>目标：降低模型的复杂度<ul>
<li>优化目标加正则项</li>
<li>决策树：剪枝</li>
<li>神经网络：early stop, dropout</li>
<li>数据增广（训练集越大，越不容易过拟合）<ul>
<li>计算机视觉：图像旋转，缩放，剪切</li>
<li>自然语言处理：同义词替换</li>
<li>语音识别：添加随机噪声</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="深层网络的局部极小值产生的原因"><a href="#深层网络的局部极小值产生的原因" class="headerlink" title="深层网络的局部极小值产生的原因"></a>深层网络的局部极小值产生的原因</h3><ul>
<li>深层网络的局部极小值主要是多个隐层复合导致的。</li>
<li><code>ReLU</code> 就是凸激活函数，但多个凸激活函数的复合也不一定是凸的。</li>
</ul>
<h3 id="逐层预训练真的是为了找到更好的局部极小值么？"><a href="#逐层预训练真的是为了找到更好的局部极小值么？" class="headerlink" title="逐层预训练真的是为了找到更好的局部极小值么？"></a>逐层预训练真的是为了找到更好的局部极小值么？</h3><p>其在一定的程序上可以帮助找到更好的局部极小值。但是，深度网络参数太多，梯度下降在非常高维空间进行，很难在所有上都是局部最小的局部极小值。大多数情况参数落在了鞍点处：某些维度上是最低点，某些维度上是最高点。</p>
<p>可以通过增加扰动很容易跳出鞍点的方法来摆脱鞍点。</p>
<h1 id="pytorch基本操作"><a href="#pytorch基本操作" class="headerlink" title="pytorch基本操作"></a>pytorch基本操作</h1><h2 id="安装并导入pytorch库"><a href="#安装并导入pytorch库" class="headerlink" title="安装并导入pytorch库"></a>安装并导入pytorch库</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import torch</span><br></pre></td></tr></table></figure>

<h2 id="创建一个Tensor"><a href="#创建一个Tensor" class="headerlink" title="创建一个Tensor"></a>创建一个Tensor</h2><ul>
<li>ones:创建一个全为1的张量</li>
<li>zeros:创建一个全为0的张量</li>
<li>eye:创建一个单位矩阵</li>
<li>arange:创建一个从开始值到结束值的等差数列张量</li>
<li>linspace:创建一个在指定区间内的等间隔数列张量</li>
<li>rand:创建一个在[0, 1)区间内均匀分布的随机数张量</li>
<li>randn:创建一个标准正太分布(均值为0，标准差为1)的随机数张量</li>
<li>normal:创建一个正太分布的随机数张量，可以指定均值与标准差</li>
<li>uniform：创建一个均匀分布的随机数张量</li>
<li>randperm：创建一个包含从0到n-1的随机排列的张量</li>
<li>empty：创建一个空张量-&gt;使用该函数创建的张量是没有被初始化的，不可以直接使用</li>
</ul>
<p>使用以上的函数创建的变量与使用tensor函数创建的变量是一个类型</p>
<h3 id="创建时指定数据类型"><a href="#创建时指定数据类型" class="headerlink" title="创建时指定数据类型"></a>创建时指定数据类型</h3><p>创建时指定变量的类型：在函数的最后一行加入 dtype&#x3D;torch.[类型]即可。可以使用的类型有：torch.float32, torch.float64, torch.float16, torch.uint8, torch.int8, torch.int16, torch.int32, torch.int64</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">m = torch.zeros(2, 3, 4, dtype=tensor.long)</span><br></pre></td></tr></table></figure>

<h2 id="利用原来的张量生成一个新的张量"><a href="#利用原来的张量生成一个新的张量" class="headerlink" title="利用原来的张量生成一个新的张量"></a>利用原来的张量生成一个新的张量</h2><h3 id="创建的张量与原来张量设备属性与数据类型一致"><a href="#创建的张量与原来张量设备属性与数据类型一致" class="headerlink" title="创建的张量与原来张量设备属性与数据类型一致"></a>创建的张量与原来张量设备属性与数据类型一致</h3><p>可以使用<code>new_*()</code>函数来在原有的张量上生成一个新张量。通过这种方式，可以利用原有的tensor的dtype，device，的属性信息。即：数据类型与设备属性的信息一样。</p>
<h3 id="创建的张量与原来张量的维度一致"><a href="#创建的张量与原来张量的维度一致" class="headerlink" title="创建的张量与原来张量的维度一致"></a>创建的张量与原来张量的维度一致</h3><p>可以使用<code>*_like()</code>函数在创建。同时，其设备属性与数据类型也会保持一致。</p>
<p><code>randn_like</code> 函数是 PyTorch 中用于创建一个与给定张量形状相同的张量，但其元素是从标准正态分布（均值为0，标准差为1）中随机采样得到的。这个函数非常方便，尤其是在需要创建与现有张量形状相同但具有随机值的张量时。</p>
<p>使用方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">torch.randn_like(input, *, dtype=None, layout=None, device=None, requires_grad=False, memory_format=torch.preserve_format)</span><br></pre></td></tr></table></figure>

<p>参数说明</p>
<ul>
<li>input: 需要指定形状的参考张量。</li>
<li>dtype (可选): 指定输出张量的数据类型。如果不指定，则使用 input 的数据类型。</li>
<li>layout (可选): 指定输出张量的布局。如果不指定，则使用 input 的布局。</li>
<li>device (可选): 指定输出张量的设备（如 CPU 或 GPU）。如果不指定，则使用 input 的设备。</li>
<li>requires_grad (可选): 如果设置为 True，则输出张量会记录操作以便进行自动求导。 memory_format (可选): 指定输出张量的内存格式。</li>
</ul>
<h3 id="完全复制一个张量"><a href="#完全复制一个张量" class="headerlink" title="完全复制一个张量"></a>完全复制一个张量</h3><p>可以使用<code>torch.clone()</code>函数来复制一个张量。两个张量内容完全相同，但是相互不影响。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">d = torch.arange(<span class="number">0</span>, <span class="number">10</span>, <span class="number">2</span>)  <span class="comment"># 创建一个从0到10（不包括10），步长为2的张量</span></span><br><span class="line"><span class="built_in">print</span>(d)</span><br><span class="line">d1 = torch.arange(<span class="number">1</span>, <span class="number">10</span>)</span><br><span class="line"><span class="built_in">print</span>(d1)</span><br><span class="line">e = torch.linspace(<span class="number">0</span>, <span class="number">1</span>, steps=<span class="number">5</span>)  <span class="comment"># 创建一个从0到1，包含5个等间隔数的张量</span></span><br><span class="line"><span class="built_in">print</span>(e)</span><br><span class="line">g = torch.randn(<span class="number">2</span>, <span class="number">4</span>)  <span class="comment"># 创建一个2x4的张量，元素为标准正态分布的随机数</span></span><br><span class="line"><span class="built_in">print</span>(g)</span><br><span class="line">i = torch.empty(<span class="number">2</span>, <span class="number">2</span>).uniform_(<span class="number">0</span>, <span class="number">10</span>)  <span class="comment"># 创建一个2x2的张量，元素为[0, 1)区间内的均匀分布随机数</span></span><br><span class="line"><span class="built_in">print</span>(i)</span><br><span class="line">j = torch.empty(<span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(j)</span><br><span class="line"></span><br><span class="line">tx = torch.ones(<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">ty = tx.new_ones(<span class="number">5</span>,<span class="number">4</span>)</span><br><span class="line"><span class="built_in">print</span>(ty)</span><br><span class="line">tz = torch.ones_like(tx)</span><br><span class="line"><span class="built_in">print</span>(tz)</span><br><span class="line"></span><br><span class="line">tcopy = torch.clone(ty)</span><br><span class="line"><span class="built_in">print</span>(tcopy)</span><br></pre></td></tr></table></figure>

<h2 id="pytorch的操作"><a href="#pytorch的操作" class="headerlink" title="pytorch的操作"></a>pytorch的操作</h2><h3 id="size函数"><a href="#size函数" class="headerlink" title="size函数"></a><code>size</code>函数</h3><p>在pytorch中，<code>size()</code>函数用于获取张量的尺寸。<code>有常见的两种用法：</code></p>
<ol>
<li><p>获取张量的整体尺寸：直接调用size函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">m = torch.Tensor([[2, 5, 3, 7],</span><br><span class="line">       [4, 2, 1, 9]])</span><br><span class="line">m.size()</span><br></pre></td></tr></table></figure>
</li>
<li><p>获取张量在特定维度上的尺寸 调用<code>size(dim)</code>，<code>dim</code>表示维度的索引，可以返回在该维度上的大小。第0维表示行数，第1维表示列数</p>
</li>
</ol>
<h3 id="numel-函数"><a href="#numel-函数" class="headerlink" title="numel()函数"></a><code>numel()</code>函数</h3><p>该函数用于返回一个张量中的元素的数量</p>
<h3 id="矩阵相乘"><a href="#矩阵相乘" class="headerlink" title="矩阵相乘"></a>矩阵相乘</h3><ul>
<li>使用<code>@</code>来完成矩阵相乘</li>
<li>使用<code>*</code>来完成逐元素相乘</li>
</ul>
<h3 id="矩阵转置"><a href="#矩阵转置" class="headerlink" title="矩阵转置"></a>矩阵转置</h3><ul>
<li>使用<code>.t()</code>函数完成转置</li>
<li>在 PyTorch 中，transpose 函数用于交换张量的两个维度，从而实现矩阵的转置操作。具体来说，transpose 函数可以用于交换任意两个维度，而不仅仅是二维矩阵的行和列。</li>
</ul>
<p><code>.t()</code>是<code>.transpose(0,1)</code>的简写</p>
<h3 id="矩阵拼接"><a href="#矩阵拼接" class="headerlink" title="矩阵拼接"></a>矩阵拼接</h3><ul>
<li>使用<code>.cat()</code>函数完成拼接</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">m = torch.ones(<span class="number">2</span>,<span class="number">4</span>, dtype=torch.long)</span><br><span class="line"><span class="built_in">print</span>(m)</span><br><span class="line"><span class="built_in">print</span>(m.size(<span class="number">0</span>), m.size(<span class="number">1</span>), m.size(), sep=<span class="string">&#x27; -- &#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(m.numel()) <span class="comment"># 24 = 2 * 3 * 4</span></span><br><span class="line"><span class="built_in">print</span>(m[<span class="number">0</span>][<span class="number">2</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回第0列的所有的元素</span></span><br><span class="line"><span class="built_in">print</span>(m[:,<span class="number">0</span>])</span><br><span class="line"><span class="comment"># 返回第1行的所有的元素</span></span><br><span class="line"><span class="built_in">print</span>(m[<span class="number">1</span>,:])</span><br><span class="line"></span><br><span class="line">v = torch.arange(<span class="number">1</span>,<span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span>(m)</span><br><span class="line"><span class="built_in">print</span>(v)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(m@v)</span><br><span class="line"><span class="built_in">print</span>(m*v)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在PyTorch中，v的形状是(4,)，这意味着它是一个一维张量，包含4个元素。这个一维向量既可以解释为行向量，也可以解释为列向量，具体取决于操作的上下文。</span></span><br><span class="line"><span class="comment"># 进行矩阵乘法m@v时，PyTorch会自动将v解释为一个列向量（即形状为(4,1)的矩阵），因为这是符合矩阵乘法规则的解释方式。矩阵乘法要求m的列数与v的行数匹配</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(m[[<span class="number">0</span>],:].size())</span><br><span class="line"><span class="built_in">print</span>(m[[<span class="number">0</span>],:]@v)</span><br><span class="line"><span class="built_in">print</span>(m[<span class="number">0</span>,:].size())</span><br><span class="line"><span class="built_in">print</span>(m[<span class="number">0</span>,:]@v)</span><br><span class="line"></span><br><span class="line"><span class="comment">#m[0, :]:</span></span><br><span class="line"><span class="comment">#返回张量 m 的第一行。</span></span><br><span class="line"><span class="comment">#返回结果是一个一维张量，形状为 (4,)。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#m[[0], :]:</span></span><br><span class="line"><span class="comment">#返回张量 m 的第一行，但保持了二维张量的形状。</span></span><br><span class="line"><span class="comment">#返回结果是一个二维张量，形状为 (1, 4)。</span></span><br><span class="line"></span><br><span class="line">addNum = torch.zeros(<span class="number">2</span>, <span class="number">4</span>)</span><br><span class="line"><span class="comment"># 矩阵相加时，要求其形状相同</span></span><br><span class="line"><span class="built_in">print</span>(m + addNum)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(m)</span><br><span class="line"><span class="built_in">print</span>(m.t())</span><br><span class="line"><span class="built_in">print</span>(m.transpose(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用transpose交换高维矩阵</span></span><br><span class="line">highdim = torch.rand(<span class="number">3</span>, <span class="number">4</span>, <span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(highdim)</span><br><span class="line"><span class="built_in">print</span>(highdim.transpose(<span class="number">1</span>, <span class="number">2</span>))</span><br><span class="line"><span class="comment"># 第一维的2与第2给的1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用matplotlib来绘图</span></span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line">plt.hist(torch.randn(<span class="number">1000</span>).numpy(), <span class="number">10</span>);</span><br></pre></td></tr></table></figure>

<h2 id="使用pytorch来构建一个线性神经网络"><a href="#使用pytorch来构建一个线性神经网络" class="headerlink" title="使用pytorch来构建一个线性神经网络"></a>使用pytorch来构建一个线性神经网络</h2><h3 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h3><h4 id="线性层"><a href="#线性层" class="headerlink" title="线性层"></a>线性层</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nn.Linear(in_features, out_features, bias=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>

<p><code>in_features</code> 是输入特征的数量，<code>out_features</code> 是输出特征的数量。</p>
<h4 id="卷积层"><a href="#卷积层" class="headerlink" title="卷积层"></a>卷积层</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nn.Conv2d(in_channels, out_channels, kernel_size, stride=<span class="number">1</span>, padding=<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<p><code>in_channels</code> 是输入通道数，<code>out_channels</code> 是输出通道数，<code>kernel_size</code> 是卷积核大小。</p>
<h4 id="循环层"><a href="#循环层" class="headerlink" title="循环层"></a>循环层</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nn.LSTM(input_size, hidden_size, num_layers=<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p><code>input_size</code> 是输入特征的数量，<code>hidden_size</code> 是隐藏层特征的数量，<code>num_layers</code> 是LSTM层的数量</p>
<h3 id="激活函数"><a href="#激活函数" class="headerlink" title="激活函数"></a>激活函数</h3><h4 id="ReLU"><a href="#ReLU" class="headerlink" title="ReLU"></a>ReLU</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nn.ReLU()</span><br></pre></td></tr></table></figure>

<p>常用于隐藏层的激活函数，能够引入非线性。</p>
<h4 id="Sigmoid"><a href="#Sigmoid" class="headerlink" title="Sigmoid"></a>Sigmoid</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nn.Sigmoid()</span><br></pre></td></tr></table></figure>

<p>将输入映射到 (0, 1) 之间，常用于二分类任务的输出层。</p>
<h4 id="Tanh"><a href="#Tanh" class="headerlink" title="Tanh"></a>Tanh</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nn.Tanh()</span><br></pre></td></tr></table></figure>

<p>将输入映射到 (-1, 1) 之间。</p>
<h4 id="Softmax"><a href="#Softmax" class="headerlink" title="Softmax"></a>Softmax</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nn.Softmax(dim=x)</span><br></pre></td></tr></table></figure>

<p>常用于多分类问题的输出层，将输出转换为概率分布。</p>
<h3 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h3><p>损失函数（也称为成本函数）是评估模型预测结果与真实标签之间差异的度量。通过最小化损失函数的值，可以优化模型的参数，使其预测结果更加准确。</p>
<h4 id="交叉熵损失"><a href="#交叉熵损失" class="headerlink" title="交叉熵损失"></a>交叉熵损失</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nn.CrossEntropyLoss()</span><br></pre></td></tr></table></figure>

<p>常用于多分类任务。</p>
<h4 id="均方误差"><a href="#均方误差" class="headerlink" title="均方误差"></a>均方误差</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nn.MSELoss()</span><br></pre></td></tr></table></figure>

<p>常用于回归任务。</p>
<h4 id="负对数似然损失"><a href="#负对数似然损失" class="headerlink" title="负对数似然损失"></a>负对数似然损失</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nn.NLLLoss()</span><br></pre></td></tr></table></figure>

<p>常与 <code>nn.LogSoftmax</code> 一起使用。</p>
<h4 id="平滑-L1-损失"><a href="#平滑-L1-损失" class="headerlink" title="平滑 L1 损失"></a>平滑 <code>L1</code> 损失</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nn.SmoothL1Loss()</span><br></pre></td></tr></table></figure>

<p>结合了L1和L2损失的优点，适用于回归任务。</p>
<h4 id="二元交叉熵损失"><a href="#二元交叉熵损失" class="headerlink" title="二元交叉熵损失"></a>二元交叉熵损失</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nn.SmoothL1Loss()</span><br></pre></td></tr></table></figure>

<p>用于二分类任务，计算二元交叉熵损失。</p>
<h3 id="线性网络模板"><a href="#线性网络模板" class="headerlink" title="线性网络模板"></a>线性网络模板</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义学习率与L2 正则化参数</span></span><br><span class="line"></span><br><span class="line">learning_rate = <span class="number">1e-3</span></span><br><span class="line">lambda_l2 = <span class="number">1e-5</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义模型</span></span><br><span class="line">model = nn.Sequential(</span><br><span class="line">    nn.Linear(D, H),</span><br><span class="line">    nn.ReLU(),</span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line">    nn.Linear(H, C),</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 部署模型</span></span><br><span class="line">model.to(device)</span><br><span class="line"><span class="comment"># 选择一个损失函数</span></span><br><span class="line">criterion = torch.nn.xxx</span><br><span class="line"><span class="comment"># 选择一个优化器</span></span><br><span class="line">optimizer = torch.optim.xxx</span><br><span class="line"></span><br><span class="line"><span class="comment">#训练</span></span><br><span class="line"><span class="keyword">for</span> t <span class="keyword">in</span> <span class="built_in">range</span>(xxx):</span><br><span class="line">  <span class="comment"># 计算预测的结果</span></span><br><span class="line">  y_pred = model(X)</span><br><span class="line">  <span class="comment"># 计算损失</span></span><br><span class="line">  <span class="comment"># criterion(predicted_value, real_value)</span></span><br><span class="line">  loss = criterion(y_pred, Y)</span><br><span class="line">  <span class="comment">#其他的处理</span></span><br><span class="line">  <span class="comment"># 将梯度置0</span></span><br><span class="line">  optimizer.zero_grad()</span><br><span class="line">  <span class="comment"># 反向传播优化</span></span><br><span class="line">  loss.backward()</span><br><span class="line">  <span class="comment"># 更新全部参数</span></span><br><span class="line">  optimizer.step()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 训练完成</span></span><br></pre></td></tr></table></figure>

<h4 id="使用pytorch构建无隐层网络，单隐层网络，双隐层网络"><a href="#使用pytorch构建无隐层网络，单隐层网络，双隐层网络" class="headerlink" title="使用pytorch构建无隐层网络，单隐层网络，双隐层网络"></a>使用pytorch构建无隐层网络，单隐层网络，双隐层网络</h4><blockquote>
<p>IN:输入的维度，OT:输出的维度，H:隐层维度<br>上下层之间的网络的维度要对齐</p>
</blockquote>
<p>无隐层网络</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nn.Sequential(</span><br><span class="line">    nn.Linear(IN, OT)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>单隐层网络</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">nn.Sequential(</span><br><span class="line">    nn.Linear(IN, H),</span><br><span class="line">    nn.ReLU(),</span><br><span class="line">    nn.Linear(H, OT)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>双隐层网络</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">nn.Sequential(</span><br><span class="line">    nn.Linear(IN, H),</span><br><span class="line">    nn.ReLU(),</span><br><span class="line">    nn.Linear(H, H),</span><br><span class="line">    nn.ReLU(),</span><br><span class="line">    nn.Linear(H, OT)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h1 id="课后作业"><a href="#课后作业" class="headerlink" title="课后作业"></a>课后作业</h1><h2 id="代码练习"><a href="#代码练习" class="headerlink" title="代码练习"></a>代码练习</h2><ol>
<li><a target="_blank" rel="noopener" href="https://colab.research.google.com/drive/1hvqOUEPzpuY25QkOHNs0IIPQD1dC74JZ?usp=sharing">pytorch基本使用</a></li>
<li><a target="_blank" rel="noopener" href="https://colab.research.google.com/drive/1RoalEDaTJLggje9pdfod_CrS6G8Z8O19?usp=sharing">螺旋数据分类</a></li>
</ol>
<p>文件中的重点内容均已整理到上文中。</p>
<ul>
<li>使用pytorch完成矩阵计算</li>
</ul>
<img data-src="http://kodo.ghost-him.com/blogPicture/study/pytorch%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8.png">

<ul>
<li>使用单隐层网络完成螺旋分类</li>
</ul>
<img data-src="http://kodo.ghost-him.com/blogPicture/study/%E4%BD%BF%E7%94%A8%E5%8D%95%E9%9A%90%E5%B1%82%E7%BD%91%E7%BB%9C%E5%AE%8C%E6%88%90%E5%88%86%E7%B1%BB.png">

<p>当时在阅读这段代码时，我原以为它与前面的代码只有模型部分不同。后来，我对之前代码的模型部分进行了修改（在两个线性层之间加入<code>ReLU</code>激活函数），但发现准确度始终无法提升。对比参考代码后，我发现优化器也从 <code>SGD</code> 改成了 <code>Adam</code>。我能想到的一个可能的解释是：<code>SGD</code> 可能陷入了局部最优解，而使用 <code>Adam</code> 则有助于跳出局部最优解。</p>
<ul>
<li>代码中可能存在的小问题</li>
</ul>
<img data-src="http://kodo.ghost-him.com/blogPicture/study/%E4%BB%A3%E7%A0%81%E4%B8%AD%E5%8F%AF%E8%83%BD%E7%9A%84%E9%97%AE%E9%A2%98.png">

<p>文件<code>plot_lib.py</code>中第40行代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zieger = plt.imread(<span class="string">&#x27;res/ziegler.png&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>该代码要求读取工作目录下<code>res</code>文件夹中的<code>ziegler.png</code>文件。</p>
<p>但是该文件并没有下载。所以要使用以下代码来下载文件：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">!wget https://raw.githubusercontent.com/Atcold/pytorch-Deep-Learning/master/res/ziegler.png</span><br></pre></td></tr></table></figure>

<p>并在工作目录下新建一个目录<code>res</code>，然后将下载下来的图片放到该文件夹中即可。</p>
<h2 id="问题回答"><a href="#问题回答" class="headerlink" title="问题回答"></a>问题回答</h2><h3 id="AlexNet有哪些特点？为什么可以⽐LeNet取得更好的性能？"><a href="#AlexNet有哪些特点？为什么可以⽐LeNet取得更好的性能？" class="headerlink" title="AlexNet有哪些特点？为什么可以⽐LeNet取得更好的性能？"></a>AlexNet有哪些特点？为什么可以⽐LeNet取得更好的性能？</h3><p>在大结构上，传承了<code>LeNet</code>的基本结构：卷积与池化。</p>
<p>其性能会更好的原因有以下三点：</p>
<ol>
<li><code>AlexNet</code>采用了<code>ReLU</code>激活函数，来代替<code>Sigmoid</code>函数来对输入的非线性进行优化，其计算成本更低。同时，<code>ReLU</code>不会在饱和区域产生梯度消失而减慢收敛速度的情况。此外，<code>ReLU</code>增加了矩阵的稀疏性，从而防止了过拟合。</li>
<li><code>AlexNet</code>在全链接刷去采用了<code>DropOut</code>技术，这个技术可以让模型的泛化性更强。对消除过拟合有奇效。</li>
<li>引入了图像增广，可以扩大数据集的规模。此外，随机改变训练样本可以降低模型对某些属性的依赖，从而提高模型的泛化能力。</li>
</ol>
<h3 id="激活函数有哪些作⽤？"><a href="#激活函数有哪些作⽤？" class="headerlink" title="激活函数有哪些作⽤？"></a>激活函数有哪些作⽤？</h3><p>常见的激活函数有：</p>
<ul>
<li>ReLU:常用于隐藏层的激活函数，能够引入非线性。</li>
<li>Sigmoid:将输入映射到 (0, 1) 之间，常用于二分类任务的输出层。</li>
<li>Tanh:将输入映射到 (-1, 1) 之间。</li>
<li>Softmax:常用于多分类问题的输出层，将输出转换为概率分布。</li>
</ul>
<h3 id="梯度消失现象是什么？"><a href="#梯度消失现象是什么？" class="headerlink" title="梯度消失现象是什么？"></a>梯度消失现象是什么？</h3><p>当神经网络在进行训练时，输入数据经过前馈传播得出结果，然后优化器则会根据误差来调整模型中的参数。调整的顺序则是从最后一层向第一层调整（反向传播）。</p>
<p>神经网络使用梯度来完成对误差的传递。但是对于某些特定的激活函数，比如<code>sigmoid</code>，当输入的值较大时，其导数则可能趋近于0。此时，上一层接收到的梯度就变得很小，等上一层调整完以后还要再次传递到上上一层，此时，梯度的值可能也会趋近于0。上上一层收到趋近于0的梯度则对其调整几乎没有参考意义。</p>
<p>因此，在训练后，底层的网络层调整的很好，可是顶层却几乎没有被调整（收到的梯度很小，无法受到有效的调整）。这个现象就是梯度消失。</p>
<h3 id="神经⽹络是更宽好还是更深好？"><a href="#神经⽹络是更宽好还是更深好？" class="headerlink" title="神经⽹络是更宽好还是更深好？"></a>神经⽹络是更宽好还是更深好？</h3><ul>
<li><p>在神经元总数相当的情况下，增加网络深度可以比增加宽度带来更强的网络表示能力：产生更多的线性区域</p>
</li>
<li><p>深度和宽度对函数复杂度的贡献是不同的，深度的贡献是指数增长的，而宽度的贡献是线性的。</p>
</li>
</ul>
<h3 id="为什么要使⽤Softmax"><a href="#为什么要使⽤Softmax" class="headerlink" title="为什么要使⽤Softmax?"></a>为什么要使⽤Softmax?</h3><p>在多分类问题，softmax函数可以将模型的输出转换为每个类的概率，这样可以很方便的确定输入的数据属于哪个类别。</p>
<h3 id="SGD-和-Adam-哪个更有效？"><a href="#SGD-和-Adam-哪个更有效？" class="headerlink" title="SGD 和 Adam 哪个更有效？"></a>SGD 和 Adam 哪个更有效？</h3><p><code>SGD</code>与<code>Adam</code>各有各的优点，通常情况下<code>Adam</code>有更好的表现。</p>
<h2 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h2><ol>
<li>既然自编码器的目标是将隐层可以最大程度的表示输入，那么为什么不直接取消该层，直接使用输入的数据？</li>
</ol>
<p>自编码器可以提取输入数据的整体的结构，如果目标模型不需要关注细节，只需要关注整体结构，则可以使用自编码器。此外，自编码器还可以完成图像的修复，比如去噪，去雨，去雾，超分辨率等。</p>
<ol start="2">
<li>不同的激活函数对应不同的效果，是不是在写代码的时候直接无脑选择当前最先进的激活函数？</li>
</ol>
<p>激活函数一般使用<code>ReLU</code>就已经可以获得足够的效果。</p>
<ol start="3">
<li>像受限玻耳兹曼机的条件概率建模，要不要学习这些公式。</li>
</ol>
<p>不用学习公式了，RBM已经淘汰了，不需要看了。</p>

    </div>

    
    
    

    <footer class="post-footer">
          

<div class="post-copyright">
<ul>
  <li class="post-copyright-author">
      <strong>原作者： </strong>ghost-him
  </li>
  <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="http://example.com/posts/af92fc3c/" title="深度学习：算法到实战学习笔记01">http://example.com/posts/af92fc3c/</a>
  </li>
  <li class="post-copyright-license">
      <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/zh-CN" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/posts/1ad6d8ff/" rel="prev" title="arch linux安装nvidia驱动">
                  <i class="fa fa-angle-left"></i> arch linux安装nvidia驱动
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/posts/369bad86/" rel="next" title="深度学习：算法到实战学习笔记02">
                  深度学习：算法到实战学习笔记02 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">ghost-him</span>
  </div>

<span id="timeDate">载入天数...</span>
<script>
    var now = new Date();
    function createtime() {
        var grt= new Date("03/10/2023 00:34:47");//在此处修改你的建站时间
        now.setTime(now.getTime()+250);
        days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days);
        hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours);
        if(String(hnum).length ==1 ){hnum = "0" + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum);
        mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = "0" + mnum;}
        seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);
        snum = Math.round(seconds); if(String(snum).length ==1 ){snum = "0" + snum;}
        document.getElementById("timeDate").innerHTML = "小破站已安全运行 "+dnum+" 天 | " + hnum + " 小时 " + mnum + " 分 " + snum + " 秒😘";
    }
setInterval("createtime()",250);
</script>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

  <a href="https://github.com/ghost-him" class="github-corner" title="在 GitHub 上关注我" aria-label="在 GitHub 上关注我" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>

</body>
</html>
